The Huffman Coding problem is implemented based on heapq, Python's built-in Heap Queue algorithm (a.k.a. priority queue).
The Node class is used for representing our data, which consist of characters, its frequencies, left and right nodes. To
compare nodes in a heap the following methods: __lt__ and __eq__  are overridden.

To calculate characters' frequencies in a text get_frequency function is used. By traversing each character in a text we
store it as a key and increment the number of occurrence as a value in dictionary. The time and space complexity for this
operation takes O(n).

The create_heap function is used for creating a priority queue. For each element of the dictionary we create a Node
object and push it into a heap. Python's built-in heapq takes O(logn) time for push and pop operations and O(nlogn)
for sorting. The time complexity of the create_heap function is O(nlogn) and O(n) for the space complexity.

The merge_nodes function is used for creating a tree. It iterates over a heap elements until there is only one element
is left. It pops two nodes from the heap, sums their frequencies, creates a new node with sum of frequencies, adds
those nodes as its left and right children and push it back to the heap. The time and space complexity of this function
is O(n).

The binaryze function is used for generating a code for each character in the tree, placing a o if traverses to the left
or 1 to the right. It returns a dictionary of the generated code, the time and space complexity of the function is O(n).

The reverse function is used for reversing a dictionary of the generated codes. It takes O(n) for time and space
complexity.

The huffman_encoding function consists of the other mentioned functions for encoding and it takes O(nlogn) time.

The huffman_decoding function decodes encoded text by using reversed codes, it iterates over encoded text and finds
characters. The time and space complexity of this function is O(n).